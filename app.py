from flask import Flask, render_template, request, redirect, url_for, flash, jsonify
from flask_login import LoginManager, login_user, login_required, logout_user, current_user
from flask_socketio import SocketIO, emit, join_room, leave_room
from models import db, User, GameRound, Bet
import random
import time
import threading
from datetime import datetime
import os

# Создание приложения
app = Flask(__name__)
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'dev-secret-key-change-in-production')

# Настройка базы данных
database_url = os.environ.get('DATABASE_URL')
if database_url:
    if database_url.startswith('postgres://'):
        database_url = database_url.replace('postgres://', 'postgresql://', 1)
    app.config['SQLALCHEMY_DATABASE_URI'] = database_url
else:
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///roulette.db'

app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Инициализация расширений
db.init_app(app)
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'

# Настройка SocketIO
socketio = SocketIO(
    app, 
    cors_allowed_origins="*",
    async_mode='threading',
    logger=False,
    engineio_logger=False
)

# Глобальные переменные
current_round = None
game_state = {
    'status': 'waiting',
    'time_left': 0,
    'round_number': 1
}
game_started = False

# Числа европейской рулетки
ROULETTE_NUMBERS = {
    0: 'green',
    1: 'red', 2: 'black', 3: 'red', 4: 'black', 5: 'red', 6: 'black',
    7: 'red', 8: 'black', 9: 'red', 10: 'black', 11: 'black', 12: 'red',
    13: 'black', 14: 'red', 15: 'black', 16: 'red', 17: 'black', 18: 'red',
    19: 'red', 20: 'black', 21: 'red', 22: 'black', 23: 'red', 24: 'black',
    25: 'red', 26: 'black', 27: 'red', 28: 'black', 29: 'black', 30: 'red',
    31: 'black', 32: 'red', 33: 'black', 34: 'red', 35: 'black', 36: 'red'
}

@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

# Маршруты
@app.route('/')
def index():
    if not current_user.is_authenticated:
        return redirect(url_for('login'))
    return render_template('index.html', user=current_user)

@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form.get('username', '').strip()
        password = request.form.get('password', '')
        
        if len(username) < 3:
            flash('Логин должен содержать минимум 3 символа')
            return render_template('register.html')
        
        if len(password) < 6:
            flash('Пароль должен содержать минимум 6 символов')
            return render_template('register.html')
        
        if User.query.filter_by(username=username).first():
            flash('Пользователь с таким именем уже существует')
            return render_template('register.html')
        
        try:
            user = User(username=username)
            user.set_password(password)
            user.balance = 1000.0
            db.session.add(user)
            db.session.commit()
            flash('Регистрация успешна!')
            return redirect(url_for('login'))
        except Exception as e:
            db.session.rollback()
            flash('Ошибка при регистрации')
    
    return render_template('register.html')

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form.get('username', '').strip()
        password = request.form.get('password', '')
        
        user = User.query.filter_by(username=username).first()
        if user and user.check_password(password):
            login_user(user, remember=True)
            return redirect(url_for('index'))
        else:
            flash('Неверный логин или пароль')
    
    return render_template('login.html')

@app.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('login'))

@app.route('/profile')
@login_required
def profile():
    user_bets = Bet.query.filter_by(user_id=current_user.id)\
                        .order_by(Bet.created_at.desc()).limit(20).all()
    return render_template('profile.html', user=current_user, bets=user_bets)

@app.route('/api/place_bet', methods=['POST'])
@login_required
def place_bet():
    try:
        data = request.get_json()
        bet_type = data.get('bet_type')
        amount = float(data.get('amount'))
        
        if game_state['status'] != 'betting':
            return jsonify({'success': False, 'message': 'Ставки не принимаются'})
        
        if amount <= 0 or amount > current_user.balance:
            return jsonify({'success': False, 'message': 'Недостаточно средств'})
        
        if bet_type not in ['red', 'black', 'green']:
            return jsonify({'success': False, 'message': 'Неверный тип ставки'})
        
        if not current_round:
            return jsonify({'success': False, 'message': 'Раунд не найден'})
        
        multipliers = {'red': 2, 'black': 2, 'green': 36}
        potential_win = amount * multipliers[bet_type]
        
        bet = Bet(
            user_id=current_user.id,
            round_id=current_round.id,
            bet_type=bet_type,
            amount=amount,
            potential_win=potential_win
        )
        
        current_user.balance -= amount
        db.session.add(bet)
        db.session.commit()
        
        socketio.emit('bet_placed', {
            'username': current_user.username,
            'bet_type': bet_type,
            'amount': amount
        }, room='game')
        
        return jsonify({'success': True, 'new_balance': current_user.balance})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': 'Ошибка сервера'})

@app.route('/api/user_balance')
@login_required
def get_user_balance():
    return jsonify({'balance': current_user.balance})

@app.route('/api/recent_results')
def get_recent_results():
    try:
        recent_rounds = GameRound.query.filter(
            GameRound.winning_number.isnot(None)
        ).order_by(GameRound.end_time.desc()).limit(10).all()
        
        results = []
        for round in recent_rounds:
            results.append({
                'number': round.winning_number,
                'color': round.winning_color,
                'round': round.round_number
            })
        
        return jsonify({'results': results})
    except Exception as e:
        return jsonify({'results': []})

# Добавьте этот маршрут в app.py после существующих API маршрутов

@app.route('/api/recent_results')
def get_recent_results():
    try:
        # Получаем последние 10 завершенных раундов
        recent_rounds = GameRound.query.filter(
            GameRound.winning_number.isnot(None)
        ).order_by(GameRound.end_time.desc()).limit(10).all()
        
        results = []
        for round in recent_rounds:
            results.append({
                'number': round.winning_number,
                'color': round.winning_color,
                'round': round.round_number,
                'timestamp': round.end_time.isoformat() if round.end_time else None
            })
        
        return jsonify({'results': results})
    except Exception as e:
        print(f"Ошибка получения результатов: {e}")
        return jsonify({'results': []})

# Также добавьте API для статистики игрока
@app.route('/api/player_stats')
@login_required
def get_player_stats():
    try:
        # Общее количество ставок
        total_bets = Bet.query.filter_by(user_id=current_user.id).count()
        
        # Количество выигрышных ставок
        winning_bets = Bet.query.filter_by(
            user_id=current_user.id, 
            is_winner=True
        ).count()
        
        # Общая сумма ставок
        total_bet_amount = db.session.query(
            db.func.sum(Bet.amount)
        ).filter_by(user_id=current_user.id).scalar() or 0
        
        # Общая сумма выигрышей
        total_winnings = db.session.query(
            db.func.sum(Bet.actual_win)
        ).filter_by(user_id=current_user.id).scalar() or 0
        
        # Процент побед
        win_rate = (winning_bets / total_bets * 100) if total_bets > 0 else 0
        
        return jsonify({
            'total_bets': total_bets,
            'winning_bets': winning_bets,
            'total_bet_amount': round(total_bet_amount, 2),
            'total_winnings': round(total_winnings, 2),
            'win_rate': round(win_rate, 1),
            'net_profit': round(total_winnings - total_bet_amount, 2)
        })
        
    except Exception as e:
        print(f"Ошибка получения статистики: {e}")
        return jsonify({
            'total_bets': 0,
            'winning_bets': 0,
            'total_bet_amount': 0,
            'total_winnings': 0,
            'win_rate': 0,
            'net_profit': 0
        })

# WebSocket события
@socketio.on('connect')
def on_connect():
    if current_user.is_authenticated:
        join_room('game')
        emit('game_state', game_state)

@socketio.on('disconnect')
def on_disconnect():
    if current_user.is_authenticated:
        leave_room('game')

def get_winning_color(number):
    return ROULETTE_NUMBERS.get(number, 'green')

def process_bets(winning_number, winning_color):
    if not current_round:
        return
    
    try:
        round_bets = Bet.query.filter_by(round_id=current_round.id).all()
        
        for bet in round_bets:
            if bet.bet_type == winning_color:
                bet.is_winner = True
                bet.actual_win = bet.potential_win
                user = User.query.get(bet.user_id)
                if user:
                    user.balance += bet.actual_win
            else:
                bet.is_winner = False
                bet.actual_win = 0
        
        db.session.commit()
        
    except Exception as e:
        db.session.rollback()
        print(f'Ошибка обработки ставок: {e}')

def game_loop():
    global current_round, game_state, game_started
    
    if game_started:
        return
    
    game_started = True
    print("🎰 Игровой цикл запущен!")
    
    with app.app_context():
        while True:
            try:
                print(f"🎲 Начинается раунд #{game_state['round_number']}")
                
                # Фаза ставок (30 секунд)
                game_state['status'] = 'betting'
                game_state['time_left'] = 30
                
                current_round = GameRound(
                    round_number=game_state['round_number'],
                    status='betting'
                )
                db.session.add(current_round)
                db.session.commit()
                
                socketio.emit('new_round', {
                    'round_number': game_state['round_number'],
                    'status': 'betting',
                    'time_left': 30
                }, room='game')
                
                for i in range(30, 0, -1):
                    game_state['time_left'] = i
                    socketio.emit('timer_update', {
                        'time_left': i, 
                        'status': 'betting'
                    }, room='game')
                    time.sleep(1)
                
                print("⏰ Прием ставок завершен")
                
                # Фаза вращения (10 секунд)
                game_state['status'] = 'spinning'
                game_state['time_left'] = 10
                current_round.status = 'spinning'
                db.session.commit()
                
                winning_number = random.randint(0, 36)
                winning_color = get_winning_color(winning_number)
                
                print(f"🎯 Выпало число: {winning_number} ({winning_color})")
                
                socketio.emit('spin_start', {
                    'winning_number': winning_number,
                    'time': 10
                }, room='game')
                
                for i in range(10, 0, -1):
                    game_state['time_left'] = i
                    socketio.emit('timer_update', {
                        'time_left': i, 
                        'status': 'spinning'
                    }, room='game')
                    time.sleep(1)
                
                # Завершение раунда
                current_round.winning_number = winning_number
                current_round.winning_color = winning_color
                current_round.status = 'finished'
                current_round.end_time = datetime.utcnow()
                db.session.commit()
                
                process_bets(winning_number, winning_color)
                
                socketio.emit('round_finished', {
                    'winning_number': winning_number,
                    'winning_color': winning_color,
                    'round_number': game_state['round_number']
                }, room='game')
                
                print(f"✅ Раунд #{game_state['round_number']} завершен")
                
                game_state['round_number'] += 1
                time.sleep(3)  # Пауза между раундами
                
            except Exception as e:
                print(f'❌ Ошибка в игровом цикле: {e}')
                time.sleep(5)

# Инициализация при запуске
def initialize_app():
    with app.app_context():
        try:
            print("🗃️ Инициализация базы данных...")
            db.create_all()
            
            if User.query.count() == 0:
                print("👤 Создание тестового пользователя...")
                demo_user = User(username='demo')
                demo_user.set_password('demo123')
                demo_user.balance = 5000.0
                db.session.add(demo_user)
                db.session.commit()
                print("✅ Создан тестовый пользователь: demo/demo123")
            
            print("🚀 Запуск игрового цикла...")
            game_thread = threading.Thread(target=game_loop, daemon=True)
            game_thread.start()
            
        except Exception as e:
            print(f"❌ Ошибка инициализации: {e}")

# Инициализация приложения
initialize_app()

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    debug_mode = os.environ.get('FLASK_ENV') == 'development'
    
    print(f"🌐 Запуск приложения на порту {port}")
    print("🎰 ЕВРОПЕЙСКАЯ РУЛЕТКА ОНЛАЙН")
    print("=" * 50)
    
    socketio.run(
        app, 
        debug=debug_mode, 
        host='0.0.0.0', 
        port=port,
        allow_unsafe_werkzeug=True  # ← ЭТО ИСПРАВЛЕНИЕ!
    )
